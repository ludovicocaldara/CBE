#!/bin/bash -l
################################################
# File      : pge_database_create
# Author    : Ludovico Caldara
# Version   : 0.1
# Purpose   : Create the specific database.
#             

function Usage () {
	cat <<EOF
	Purpose: Create the specified database, the technical accounts and set the correct permissions.
	Usage: `basename $0` -d NAME [{Common Options}]
		-d NAME		Create database NAME.
		-c LC_COLLATE	Create database with the specified LC_COLLATE. This will force the creation from template0.
		-t LC_CTYPE	Create database with the specified LC_CTYPE. This will force the creation from template0.
EOF
}

function Cleanup () {
	if [ "$CBE_PG_LOG_REPO" == "YES" ] ; then
		TAB_NAME='pge_database_create'
		SEQ_NAME='pge_database_create_id_seq'

		edumpvar PGPASSFILE
		SEQ_ID=`F_sequence_nextval $SEQ_NAME`
	        F_check_exit $? "Getting sequence nextval"

		if [ $1 -ne 0 ] ; then
			STATUS='error'
		else
			STATUS='ok'
		fi
        	$CBE_PGHOME/bin/psql ${CBE_PG_REPO_CONN} << EOF
		\lo_import '$CBE_LOGFILE'
		\set lo :LASTOID
		INSERT INTO $TAB_NAME ( id
		 	, start_date
			, end_date
			, status
			, database_name
			, lc_ctype
			, lc_collate
			, pg_cluster
			, server_name
			, sreq
			, username
			, log
		) VALUES ( $SEQ_ID
		 	, to_timestamp('${CBE_DATETIME}','YYYYMMDD_HH24MISS')
			, current_timestamp
			, '$STATUS'
			, '${DATABASE_NAME}'
			, '$LCTYPE'
			, '$LCCOLLATE'
			, '${CBE_PG_CLUSTER}'
			, '$HOSTNAME'
			, '${CBE_SREQ}'
			, '${CBE_JOBUSER}'
			, encode(lo_get(:lo),'escape')
		);
		\lo_unlink :lo
        	\q
EOF
	        F_check_exit $? "inserting the information into the database"
	fi
}

CBE_PARSE_OPTIONS="d:c:t:"
CBE_MUSTBE=postgres
CBE_JOBUSER=${CBE_JOBUSER:-required}

CBE_BASE=${CBE_BASE:-~/CBE}
CBE_HOME=${CBE_HOME:-$CBE_BASE/CBE}
. $CBE_HOME/postgres/init_script.conf

while getopts ":${CBE_PARSE_OPTIONS}${CBE_PR_PARSE_OPTIONS}" opt ; do
	case $opt in
		d)
			edebug "Got parameter -d. Its value is $OPTARG"
			DATABASE_NAME=$OPTARG
			;;
		c)
			edebug "Got parameter -c. Its value is $OPTARG"
			LCCOLLATE=$OPTARG
			;;
		t)
			edebug "Got parameter -t. Its value is $OPTARG"
			LCTYPE=$OPTARG
			;;
		\?)
			eerror "Invalid option: -$OPTARG"
			Usage
			F_common_usage
			exit 1
			;;
		:)
			eerror "Option -$OPTARG requires an argument."
			Usage
			F_common_usage
			exit 1
			;;
	esac
done

## an environment must be set either with pgenv or with the -e parameter
F_check_env_set
F_check_exit $? "Environment check"

if ! [ $DATABASE_NAME ] ; then
	eerror "Please specify a database name with the option -d NAME."
	exit 1
fi

CBE_PG_LOG_REPO=${CBE_PG_LOG_REPO:-"NO"}

Job=${Job}_${CBE_PG_CLUSTER}_${DATABASE_NAME}

F_start_logging

TEMPLATE0=""
[ $LCTYPE ] || [ $LCCOLLATE ] && TEMPLATE0="TEMPLATE=template0"
LCTYPE=${LCTYPE:-en_US.UTF8}
LCCOLLATE=${LCCOLLATE:-en_US.UTF8}
edebug TEMPLATE0 LCTYPE LCCOLLATE

einfo "New database name: $DATABASE_NAME"

enotify "Creating the database $DATABASE_NAME"
$CBE_PGHOME/bin/psql -e -U $CBE_PG_SUPER postgres <<EOF
	\set ON_ERROR_STOP true
	create database ${DATABASE_NAME} ${LCTYPE:+LC_CTYPE='${LCTYPE}'} ${LCCOLLATE:+LC_COLLATE='${LCCOLLATE}'} $TEMPLATE0;
EOF
F_check_exit $? "Create database $DATABASE_NAME "

enotify "Creating the technical users and fixing the privileges"

OWNER_EXISTS=`pquery "SELECT 'EXISTS' FROM  pg_catalog.pg_user WHERE  usename ='${DATABASE_NAME}_owner';"`
USER_EXISTS=`pquery "SELECT 'EXISTS' FROM  pg_catalog.pg_user WHERE  usename ='${DATABASE_NAME}_user';"`
READ_EXISTS=`pquery "SELECT 'EXISTS' FROM  pg_catalog.pg_user WHERE  usename ='${DATABASE_NAME}_read';"`

PASS_OWNER=`F_genpasswd 32`
PASS_USER=`F_genpasswd 32`
PASS_READ=`F_genpasswd 32`
$CBE_PGHOME/bin/psql -e -U $CBE_PG_SUPER $DATABASE_NAME <<EOF
	\set ON_ERROR_STOP true
	revoke all privileges on schema public from public;
	-- create base users
	\set ECHO errors
	DO
	\$body\$
	BEGIN
	IF NOT EXISTS (SELECT * FROM   pg_catalog.pg_user WHERE  usename = '${DATABASE_NAME}_owner') THEN
		create role ${DATABASE_NAME}_owner login password '${PASS_OWNER}';
	END IF;
	IF NOT EXISTS (SELECT * FROM   pg_catalog.pg_user WHERE  usename = '${DATABASE_NAME}_user') THEN
	create role ${DATABASE_NAME}_user login password '${PASS_USER}';
	END IF;
	IF NOT EXISTS (SELECT * FROM   pg_catalog.pg_user WHERE  usename = '${DATABASE_NAME}_read') THEN
	create role ${DATABASE_NAME}_read login password '${PASS_READ}';
	END IF;
	END
	\$body\$;
	\set ECHO queries
	-- give create rights to the owner
	grant all privileges on schema public to ${DATABASE_NAME}_owner;
	-- set the correct owner
	alter database ${DATABASE_NAME} owner to ${DATABASE_NAME}_owner;
	-- give usage rights to the read and read write users
	grant usage on schema public to ${DATABASE_NAME}_user;
	grant usage on schema public to ${DATABASE_NAME}_read;
	-- give correct privileges to read and read write users for objects created in the public schema
	set role=${DATABASE_NAME}_owner;
	-- read just have select on tables and sequences
	alter default privileges in schema public grant select on tables to ${DATABASE_NAME}_read;
	alter default privileges in schema public grant select on sequences to ${DATABASE_NAME}_read;
	-- user have CRUD on on tables, update on sequences, execute on functions
	alter default privileges in schema public grant select, insert, update, delete, truncate on tables to ${DATABASE_NAME}_user;
	alter default privileges in schema public grant usage, select, update on sequences to ${DATABASE_NAME}_user;
	alter default privileges in schema public grant execute on functions to ${DATABASE_NAME}_user;
EOF
F_check_exit $? "Create users and fix permissions on $DATABASE_NAME"



if [ "$OWNER_EXISTS" == "EXISTS" ] ; then
	PASS_OWNER=""
	einfo "The account ${DATABASE_NAME}_owner already exists, the password did not change."
fi
if [ "$USER_EXISTS" == "EXISTS" ] ; then
	PASS_USER=""
	einfo "The account ${DATABASE_NAME}_user already exists, the password did not change."
fi
if [ "$READ_EXISTS" == "EXISTS" ] ; then
	PASS_READ=""
	einfo "The account ${DATABASE_NAME}_read already exists, the password did not change."
fi

F_stop_logging

edebug "Connection variables:"
edebug "PGHOST=`hostname`"
edebug "PGPORT=$PGPORT"
edebug "CBE_PG_CLUSTER=$CBE_PG_CLUSTER"
edebug "DATABASE=$DATABASE_NAME"
edebug "OWNER=${DATABASE_NAME}_owner"
edebug "OWNER_PASS=${PASS_OWNER}"
edebug "USER=${DATABASE_NAME}_user"
edebug "USER_PASS=${PASS_USER}"
edebug "READ=${DATABASE_NAME}_read"
edebug "READ_PASS=${PASS_READ}"

#(cat <<EOF
#Creation of database $DATABASE_NAME completed successfully on instance $CBE_PG_CLUSTER.
#
#Please forward this email to the right people.
#
#Connection variables:
#PGHOST    =`hostname`
#PGPORT    = $PGPORT
#CBE_PG_CLUSTER= $CBE_PG_CLUSTER
#DATABASE  = $DATABASE_NAME
#OWNER     = ${DATABASE_NAME}_owner
#OWNER_PASS= ${PASS_OWNER}
#USER      = ${DATABASE_NAME}_user
#USER_PASS = ${PASS_USER}
#READ      = ${DATABASE_NAME}_read
#READ_PASS = ${PASS_READ}
#
#EOF
#) | mailx -s "Database $DATABASE_NAME created on instance $CBE_PG_CLUSTER" $CBE_PG_MAILINGLIST

if [ "$PASS_OWNER" != "" ] ; then
	cat <<EOF >> $PGPASSFILE
`hostname -s`:$PGPORT:$DATABASE_NAME:${DATABASE_NAME}_owner:${PASS_OWNER}
EOF
fi

if [ "$PASS_USER" != "" ] ; then
	cat <<EOF >> $PGPASSFILE
`hostname -s`:$PGPORT:$DATABASE_NAME:${DATABASE_NAME}_user:${PASS_USER}
EOF
fi

if [ "$PASS_READ" != "" ] ; then
	cat <<EOF >> $PGPASSFILE
`hostname -s`:$PGPORT:$DATABASE_NAME:${DATABASE_NAME}_read:${PASS_READ}
EOF
fi

exit 0
